---
title: "Longest Substring Without Repeating Characters"
description: "A simple explanation and clean Python solution for this Blind 75 problem."
date: "2025-11-03"
---

# ğŸ§© Longest Substring Without Repeating Characters

You are given a string.  
Find the **longest part (substring)** that has **no repeating characters**.

---

## ğŸ”¢ Example

**Input:**
```

"abcabcbb"

````

| Substring | Has repeats? | Length |
|------------|--------------|--------|
| abc        | âœ… unique     | 3      |
| abca       | âŒ repeats    | -      |
| bca        | âœ… unique     | 3      |

âœ… **Longest substring = "abc"**  
**Answer = 3**

---

## ğŸ’¡ Real-World Example

Imagine typing a password and checking the **longest part without repeated letters**,  
since repeating ones make it weak.  

Or in music, you might check the **longest streak of non-repeating notes** ğŸµ.

---

## âš™ï¸ Approaches

### ğŸ¥‡ Approach 1: Brute Force

Try all substrings and check if all characters are unique.

```python
def longestSubstring(s):
    longest = 0
    for i in range(len(s)):
        for j in range(i, len(s)):
            part = s[i:j+1]
            if len(set(part)) == len(part):  # all unique
                longest = max(longest, len(part))
    return longest
````

â± **Time:** O(nÂ²)
ğŸ“¦ **Space:** O(n)

âœ… Easy to understand
âŒ Slow for big strings

---

### ğŸ¥ˆ Approach 2: Sliding Window (Efficient âœ…)

Use two pointers â€” `left` and `right`.
Expand `right`, shrink `left` when duplicates appear.

```python
def longestSubstring(s):
    seen = set()
    left = 0
    longest = 0

    for right in range(len(s)):
        while s[right] in seen:
            seen.remove(s[left])
            left += 1
        seen.add(s[right])
        longest = max(longest, right - left + 1)
    return longest
```

â± **Time:** O(n)
ğŸ“¦ **Space:** O(n)

âœ… Fast and simple for large input
âœ… Common interview pattern

---

### ğŸ¥‰ Approach 3: Using Dictionary (Index Map)

Keep track of the last seen index for each character.

```python
def longestSubstring(s):
    seen = {}
    left = 0
    longest = 0

    for right, char in enumerate(s):
        if char in seen and seen[char] >= left:
            left = seen[char] + 1
        seen[char] = right
        longest = max(longest, right - left + 1)
    return longest
```

â± **Time:** O(n)
ğŸ“¦ **Space:** O(n)

âœ… Cleanest version
âœ… Most preferred for interviews

---

## ğŸ§  Real-Life Uses

| Use Case             | Example                                |
| -------------------- | -------------------------------------- |
| ğŸ”‘ Password Strength | Check longest non-repeating characters |
| ğŸ“± Text Analysis     | Find unique letter streaks in input    |
| ğŸ•¹ Game Logic        | Longest unique sequence of moves       |
| ğŸ’¬ Chat Apps         | Detect longest non-repeated pattern    |

---

## âš ï¸ Drawbacks

| Drawback                    | Explanation               |
| --------------------------- | ------------------------- |
| ğŸ•’ Brute Force is slow      | Checks every substring    |
| ğŸ’¾ Uses memory              | Set/dict store characters |
| ğŸ§© Works only on characters | Modify to support words   |

---

## ğŸ” Example Dry Run

**Input:** `"pwwkew"`

| Step | Left | Right | Window               | Longest |
| ---- | ---- | ----- | -------------------- | ------- |
| 0    | 0    | 0     | "p"                  | 1       |
| 1    | 0    | 1     | "pw"                 | 2       |
| 2    | 0    | 2     | "pww" â†’ âŒ duplicate  | 2       |
| 3    | 1    | 3     | "wk"                 | 2       |
| 4    | 1    | 4     | "wke"                | 3 âœ…     |
| 5    | 1    | 5     | "wkew" â†’ âŒ duplicate | 3       |

âœ… **Final Answer = 3 ("wke")**

---

## ğŸ§¾ Summary Table

| Approach             | Logic                           | Time  | Space | Notes           |
| -------------------- | ------------------------------- | ----- | ----- | --------------- |
| Brute Force          | Try all substrings              | O(nÂ²) | O(n)  | Simple but slow |
| Sliding Window (Set) | Move window & remove duplicates | O(n)  | O(n)  | Best balance    |
| Index Map (Dict)     | Track last seen index           | O(n)  | O(n)  | Fastest âœ…       |

---

## ğŸ’¡ Key Takeaways

* Use **sliding window** for â€œlongest substringâ€ or â€œsubarrayâ€ problems.
* Use a **set or dictionary** to track duplicates.
* Practice dry runs to understand **window movement**.

---

## âœ¨ Real-World Analogy

Imagine walking on tiles labeled with letters:

```
A - B - C - A - B - C - B - B
```

You keep walking until you step on a tile youâ€™ve already seen.
Then, step back and start again.
The farthest you go without repeating = your answer.

---

## ğŸ Final Thought

This problem helps you understand:

* Sliding Window Technique ğŸšª
* HashSets & HashMaps ğŸ’¾
* Thinking in â€œexpand & shrinkâ€ windows

Once you learn this, you can easily move to:

* **Longest Subarray with Sum K**
* **Longest Substring with at most K distinct characters**
* **Minimum Window Substring**

```

---
