---
title: "Database Scaling Patterns"
description: "Detailed explanation of database scaling techniques like read replicas, sharding, partitioning, and federation with examples and code snippets."
tags:
  - SQL
  - Database
  - Scaling
  - Sharding
---

# ğŸ—„ï¸ Database Scaling Patterns

---

## âš™ï¸ 1. Read Replicas and Write Scaling

### ğŸ“˜ Concept
- A **read replica** is a copy of the **primary (main)** database.
- The **primary** handles **writes** (INSERT, UPDATE, DELETE).
- The **replicas** handle **reads** (SELECT queries).

This splits the load â€” writes go to the main DB, reads go to replicas.

### ğŸŒ Real-World Example
Think of **Instagram**:
- When you upload a photo â†’ it's a **write** operation â†’ goes to the **primary DB**.
- When millions view your photo â†’ they perform **reads** â†’ served by **read replicas**.

### ğŸ’» Example (MySQL)

```sql
-- Primary DB
INSERT INTO posts (user_id, caption, image_url)
VALUES (123, 'Beach Day', 'photo.jpg');

-- Read Replica
SELECT * FROM posts WHERE user_id = 123;
````

### âœ… Benefits

* Improves read performance
* Reduces main DB load
* Enables replicas near users for faster response

### âš ï¸ Challenges

* Slight delay in replication (replication lag)
* Writes still go to one primary â€” write scaling is limited

---

## ğŸ§© 2. Horizontal vs Vertical Partitioning

### A. Vertical Partitioning

Splitting a table by **columns** into smaller, focused tables.

#### ğŸŒ Example

You have a large `Users` table:

| id | name | email | password | bio | profile_picture |
| -- | ---- | ----- | -------- | --- | --------------- |

You can split it into:

* `UserCredentials(id, email, password)`
* `UserProfile(id, name, bio, profile_picture)`

This helps when different services need different parts of user data.

#### ğŸ’» Example

```sql
-- Query only login data
SELECT email, password FROM UserCredentials WHERE email = 'safi@example.com';

-- Query only profile info
SELECT name, bio FROM UserProfile WHERE id = 123;
```

---

### B. Horizontal Partitioning (Sharding)

Splitting a table by **rows** based on some rule, like user region or ID range.

#### ğŸŒ Example

A `Customers` table with 10 million users can be split as:

* `Customers_Asia`
* `Customers_Europe`
* `Customers_USA`

Each database handles fewer records, improving performance.

#### ğŸ’» Example (Pseudo)

```python
def get_db_for_customer(customer_id):
    if customer_id < 1000000:
        return "db_shard_1"
    elif customer_id < 2000000:
        return "db_shard_2"
    else:
        return "db_shard_3"
```

---

## ğŸŒ 3. Sharding Strategies and Challenges

**Sharding** is automated horizontal partitioning â€” splitting one big database into multiple smaller ones (shards).

### Common Sharding Strategies

1. **Range-Based Sharding**

   * Divide by value range (like user IDs)
   * Example: Shard 1 â†’ IDs 1â€“1M, Shard 2 â†’ IDs 1Mâ€“2M

2. **Hash-Based Sharding**

   * Use a hash function to assign data
   * Example: `user_id % 4` â†’ sends data to one of 4 shards

3. **Geo-Based Sharding**

   * Data stored based on userâ€™s region (Asia, Europe, USA)

#### ğŸŒ Example

**Netflix** stores usersâ€™ data in regional shards:

* Asia â†’ `Shard_Asia`
* Europe â†’ `Shard_Europe`
* USA â†’ `Shard_USA`

#### ğŸ’» Example (Hash-based)

```python
def get_shard(user_id):
    return f"shard_{user_id % 4}"
```

### âš ï¸ Challenges

* Complex queries across shards
* Rebalancing data when shards grow
* Maintaining consistency across multiple shards

---

## ğŸ” 4. Consistency vs Availability (CAP Theorem)

### CAP Theorem

A distributed database can only guarantee **two** of these three at a time:

1. **Consistency (C):** All nodes show the same data.
2. **Availability (A):** Every request gets a response.
3. **Partition Tolerance (P):** The system works even if communication between nodes fails.

### ğŸŒ Examples

| Type          | Example           | Priority                                                 |
| ------------- | ----------------- | -------------------------------------------------------- |
| **CP System** | Banking system    | Consistency first â€” balances must match                  |
| **AP System** | Social media feed | Availability first â€” show something even if slightly old |

#### ğŸ’» Example

```python
# AP System: Social media feed (eventual consistency)
feed_cache = get_cached_posts(user_id)
return feed_cache or fetch_from_db_later()
```

Twitter prefers **availability**, so it shows cached tweets immediately.

---

## ğŸ§­ 5. Database Federation Patterns

### ğŸ“˜ Concept

Each **domain** or **microservice** has its own database instead of one giant shared database.

### ğŸŒ Example (E-commerce)

* `UsersDB` â†’ manages users
* `OrdersDB` â†’ handles orders
* `ProductsDB` â†’ manages products
* `PaymentsDB` â†’ processes payments

Each team owns its data and scales independently.

#### ğŸ’» Example (API Integration)

```python
# Order Service
order = {
  "user": requests.get("http://users-service/123").json(),
  "items": requests.get("http://products-service/cart/123").json(),
}
```

### âœ… Benefits

* Easier to scale each domain separately
* Better isolation (one failure wonâ€™t affect others)
* Supports microservice architecture

### âš ï¸ Challenges

* Difficult to perform joins across databases
* Risk of data duplication
* Requires good inter-service communication (APIs)

---

## ğŸ§© Summary Table

| Pattern                            | Goal                                 | Real-World Example            | Key Challenge        |
| ---------------------------------- | ------------------------------------ | ----------------------------- | -------------------- |
| Read Replicas                      | Scale reads                          | Instagram viewing posts       | Replication lag      |
| Vertical Partitioning              | Split by columns                     | User profile vs credentials   | Complex joins        |
| Horizontal Partitioning / Sharding | Split by rows                        | Netflix regional data         | Cross-shard queries  |
| CAP Trade-offs                     | Balance consistency and availability | Banking vs Twitter            | Network partitions   |
| Federation                         | Domain-based scaling                 | Amazon with UsersDB, OrdersDB | Cross-domain queries |

---

## ğŸ§  Key Takeaways

* **Read replicas** â†’ Improve read performance.
* **Vertical partitioning** â†’ Split by columns for efficiency.
* **Horizontal partitioning (Sharding)** â†’ Split by rows for scalability.
* **CAP trade-offs** â†’ Choose between consistency and availability.
* **Federation** â†’ Split data by business domain (microservices).

---

## ğŸ’¡ Summary Code Snippet

```python
# Example: Routing logic for a sharded database
def get_user_db(user_id):
    if user_id % 2 == 0:
        return "shard_east"
    else:
        return "shard_west"

user_db = get_user_db(105)
print(f"Storing user 105 in {user_db}")
```

---

**Database scaling is not one-size-fits-all.**
Each pattern fits a specific use case â€” combine them wisely depending on your systemâ€™s **traffic, data volume, and reliability goals**.
